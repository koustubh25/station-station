
name: Myki Tracker - Docker Deployment

on:
  # Manual trigger
  workflow_dispatch:

  # Scheduled run (daily at 11 AM Melbourne time - midnight UTC = 11 AM AEDT / 10 AM AEST)
  schedule:
    - cron: '0 0 * * *'

  # Trigger after build workflow completes successfully
  workflow_run:
    workflows: ["Build and Push Docker Image"]
    types:
      - completed
    branches:
      - main

# Permissions needed for the workflow to commit back to the repository
permissions:
  contents: write  # Allows pushing commits
  actions: read    # Allows reading workflow status

jobs:
  run-myki-tracker:
    name: Run Myki Tracker in Docker
    runs-on: ubuntu-latest
    # Only run if triggered by workflow_dispatch, schedule, or successful build
    if: >
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'schedule' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Pull Docker image from Docker Hub
        run: |
          echo "Pulling Docker image from Docker Hub..."
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/mykitracker:latest

          echo "Tagging image as myki-tracker:latest for local use..."
          docker tag ${{ secrets.DOCKERHUB_USERNAME }}/mykitracker:latest myki-tracker:latest

          echo "Verifying image..."
          docker images | grep myki-tracker

      - name: Prepare configuration
        env:
          # GitHub Actions automatically passes all repository secrets as environment variables
          # The workflow will dynamically read config/myki_tracker_config.json to find user keys,
          # then look for the corresponding secrets:
          #   For user "koustubh" -> MYKI_USERNAME_KOUSTUBH, MYKI_CARDNUMBER_KOUSTUBH, MYKI_PASSWORD_KOUSTUBH
          #   For user "john" -> MYKI_USERNAME_JOHN, MYKI_CARDNUMBER_JOHN, MYKI_PASSWORD_JOHN
          #
          # Add your secrets in GitHub repo settings: Settings > Secrets and variables > Actions
          # The workflow will fail with a clear error if any required secrets are missing.
          SECRETS_CONTEXT: ${{ toJson(secrets) }}
        run: |
          echo "Creating required directories..."
          mkdir -p browser_profile output auth_data screenshots

          echo "Setting permissions for directories..."
          chmod -R 755 browser_profile output auth_data screenshots

          echo "Verifying config file exists..."
          if [ ! -f config/myki_config.json ]; then
            echo "ERROR: config/myki_config.json not found in repository!"
            exit 1
          fi

          echo "Creating .env file from GitHub secrets..."
          # Parse secrets from JSON context and create .env file dynamically
          python3 << 'PYSCRIPT'
          import json
          import os
          import sys

          # Load config to get user keys
          with open('config/myki_config.json') as f:
              config = json.load(f)

          # Get user keys from 'users' dict (excluding metadata and comments)
          users_config = config.get('users', config)  # Support both old and new format
          user_keys = [k for k in users_config.keys() if not k.startswith('_') and k != 'metadata']
          print(f"Found users in config: {', '.join(user_keys)}")

          # Load secrets from environment
          secrets_json = os.environ.get('SECRETS_CONTEXT', '{}')
          secrets = json.loads(secrets_json)

          # Create .env file
          with open('.env', 'w') as env_file:
              env_file.write("# Myki Multi-User Credentials\n")
              env_file.write("# Auto-generated from GitHub Secrets\n")

              missing_secrets = []

              for user_key in user_keys:
                  # Convert to uppercase and replace special chars
                  user_key_upper = user_key.upper().replace('-', '_').replace('.', '_')

                  # Get secret names
                  username_key = f"MYKI_USERNAME_{user_key_upper}"
                  cardnumber_key = f"MYKI_CARDNUMBER_{user_key_upper}"
                  password_key = f"MYKI_PASSWORD_{user_key_upper}"

                  # Get secret values
                  username = secrets.get(username_key)
                  cardnumber = secrets.get(cardnumber_key)
                  password = secrets.get(password_key)

                  # Check if all three exist
                  if not username or not cardnumber or not password:
                      if not username:
                          missing_secrets.append(username_key)
                      if not cardnumber:
                          missing_secrets.append(cardnumber_key)
                      if not password:
                          missing_secrets.append(password_key)
                      continue

                  # Write to .env file
                  env_file.write(f"\n# User: {user_key}\n")
                  env_file.write(f"{username_key}={username}\n")
                  env_file.write(f"{cardnumber_key}={cardnumber}\n")
                  env_file.write(f"{password_key}={password}\n")

              if missing_secrets:
                  print(f"\n❌ ERROR: Missing required GitHub secrets:")
                  for secret in missing_secrets:
                      print(f"  - {secret}")
                  print(f"\nAdd these secrets in: Settings > Secrets and variables > Actions")
                  sys.exit(1)

          print("✓ .env file created with credentials for all users")
          PYSCRIPT

          echo "Configuration ready"

      - name: Prepare Chrome profile (if available)
        run: |
          # If you have a pre-warmed Chrome profile stored as a GitHub artifact
          # or in a separate repository, download it here
          # For now, we'll use an empty profile (first-run scenario)
          echo "Using empty Chrome profile for first run"

      - name: Run Myki Tracker in Docker
        id: run_tracker
        run: |
          echo "Starting Myki Tracker Docker container..."
          # Capture logs to extract attendance.json if copy fails
          ./docker-run.sh | tee docker_run.log

          # Extract attendance.json from logs if it was dumped
          if grep -q "===== BEGIN ATTENDANCE JSON =====" docker_run.log; then
            echo "Extracting attendance.json from container logs..."
            mkdir -p output
            sed -n '/===== BEGIN ATTENDANCE JSON =====/,/===== END ATTENDANCE JSON =====/p' docker_run.log | \
              sed '1d;$d' > output/attendance.json
            echo "✓ Attendance.json extracted from logs"
            ls -lh output/attendance.json
          fi

      - name: Validate output
        id: validate
        run: |
          echo "Running health check..."
          ./docker-health-check.sh

      - name: Display run script output
        if: always()
        run: |
          echo "=== Docker Run Output ==="
          echo "Container was run with --rm flag and has been auto-removed"
          echo "Check the 'Run Myki Tracker in Docker' step output above for logs"

      - name: Commit results to repository
        if: success()
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Only commit if there are changes
          if [ -f output/attendance.json ]; then
            git add output/attendance.json
            git commit -m "chore: update attendance data [skip ci]" || echo "No changes to commit"
            git push || echo "Nothing to push"
          fi
